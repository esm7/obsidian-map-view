<script lang="ts">
    import { Notice, App, Editor, TFile } from 'obsidian';
    import { type PluginSettings } from '../settings';
    import MapViewPlugin from '../main';
    import {
        verifyOrAddFrontMatterForInline,
        appendToNoteAtHeadingOrEnd,
    } from '../utils';

    let {
        plugin,
        app,
        close,
        settings,
        editor,
        file,
        heading,
        doAfterImport = null,
    } = $props<{
        plugin: MapViewPlugin;
        app: App;
        close: () => void;
        settings: PluginSettings;
        // Editor is optional, without it, the file and heading will be used
        editor?: Editor;
        file: TFile;
        heading: string;
        doAfterImport?: () => void;
    }>();

    let fileInput = $state<HTMLInputElement>();
    let selectedFileName = $state('');
    let templateText = $state(`- [{{name}}](geo:{{coordinates}})`);
    let previewText = $state('');
    let fileContent = $state('');
    type Field = {
        xmlName: string;
        template: string;
        formatter?: (text: string) => string;
    };
    const fields: Field[] = [
        { xmlName: 'name', template: '{{name}}' },
        {
            xmlName: 'coordinates',
            template: '{{coordinates}}',
            formatter: formatCoordinates,
        },
        { xmlName: 'address', template: '{{address}}' },
        { xmlName: 'phoneNumber', template: '{{phoneNumber}}' },
        { xmlName: 'description', template: '{{description}}' },
    ];

    $effect(() => {
        if (selectedFileName && templateText) {
            previewText = kmlImport(fileContent, templateText);
        }
    });

    async function handleFileSelect(event: Event) {
        const target = event.target as HTMLInputElement;
        const files = target.files;
        if (files && files.length > 0) {
            selectedFileName = files[0].name;

            // Read the file content
            const file = files[0];
            try {
                fileContent = await file.text();
                previewText = kmlImport(fileContent, templateText);
            } catch (error) {
                console.error('Error reading file:', error);
                previewText = 'Error reading file';
            }
        }
    }

    function formatCoordinates(coordinates: string) {
        const [longitude, latitude] = coordinates
            .split(',')
            .map((coord) => coord.trim());
        return `${latitude},${longitude}`;
    }

    function kmlImport(content: string, template: string) {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(content, 'application/xml');

        // Extract folder name
        let title = null;
        const folderNameElement = xmlDoc.querySelector('Folder > name');
        if (folderNameElement) {
            title = folderNameElement.textContent;
        }

        // Initialize Markdown output
        let markdownOutput = '';

        // Add folder name as a heading if available
        if (title != null) {
            markdownOutput += `## ${title}\n\n`;
        }
        markdownOutput += `Imported on ${new Date().toISOString().split('T')[0]}\n\n`;

        const placemarks = xmlDoc.querySelectorAll('Placemark');
        for (const placemark of placemarks) {
            const elementToText = (elem: Element) =>
                elem == null ? '' : (elem.textContent?.trim() ?? '');

            let formattedText = template;
            for (const field of fields) {
                const value = elementToText(
                    placemark.querySelector(field.xmlName),
                );
                if (value) {
                    const formattedValue = field.formatter
                        ? field.formatter(value)
                        : value;
                    formattedText = formattedText.replace(
                        field.template,
                        formattedValue,
                    );
                }
            }

            markdownOutput += formattedText + '\n';
        }
        return markdownOutput;
    }

    async function importIntoNote() {
        if (previewText) {
            await verifyOrAddFrontMatterForInline(app, editor, file, settings);
            if (editor) {
                editor.replaceSelection(previewText);
            } else {
                appendToNoteAtHeadingOrEnd(file, heading, previewText, app);
            }
            if (doAfterImport) doAfterImport();
        }
        close();
    }
</script>

<div class="import-dialog">
    <div class="setting-item-container">
        <div class="setting-item-heading">Import Geolocations from File</div>
        <div class="setting-item-description">
            This tool allows batch-importing geolocations from KML files
            generated by Google Maps.
        </div>

        <div class="setting-item">
            <div class="setting-item-info">
                <div class="setting-item-name">Input file</div>
                <div class="setting-item-description">
                    Select a file to import.
                </div>
            </div>
            <div class="setting-item-control">
                <input
                    type="file"
                    accept=".kml"
                    style="display: none"
                    bind:this={fileInput}
                    onchange={handleFileSelect}
                />
                {#if selectedFileName}
                    <span class="selected-file">{selectedFileName}</span>
                {/if}
                <button class="mod-cta" onclick={() => fileInput?.click()}>
                    Select File...
                </button>
            </div>
        </div>
    </div>

    <div class="setting-item template-container">
        <div class="setting-item-info">
            <div class="setting-item-name">Template text to use</div>
            <div class="setting-item-description">
                <p>Available fields:</p>
                <p style="font-family: var(--font-monospace);">
                    {fields.map((field) => field.template).join(', ')}
                </p>
            </div>
        </div>
        <textarea rows="2" bind:value={templateText}> </textarea>
    </div>

    <div class="setting-item preview-container">
        <div class="setting-item-info">
            <div class="setting-item-name">Preview</div>
        </div>
        <textarea rows="6" readonly bind:value={previewText}></textarea>
    </div>

    <div class="setting-item">
        <div class="setting-item-control">
            <button
                class="mod-cta"
                onclick={importIntoNote}
                disabled={!previewText}
            >
                Import into Note
            </button>
            <button class="mod-cta" onclick={close}> Cancel </button>
        </div>
    </div>
</div>

<style>
    .selected-file {
        margin-left: 10px;
        color: var(--text-muted);
        font-size: 0.9em;
        max-width: 16ch;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        display: inline-block;
        vertical-align: middle;
    }

    .template-container,
    .preview-container {
        display: block !important;
    }

    .template-container .setting-item-info,
    .preview-container .setting-item-info {
        padding-bottom: var(--size-4-1);
    }

    textarea {
        width: 100%;
        resize: vertical;
        background-color: var(--background-modifier-form-field);
        border: var(--input-border-width) solid
            var(--background-modifier-border);
        color: var(--text-muted);
        font-family: var(--font-monospace);
        padding: var(--size-4-1);
        border-radius: var(--radius-s);
        min-height: 80px;
    }
</style>
