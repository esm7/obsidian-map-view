<script lang="ts">
	import { Notice, App, Editor, TFile } from 'obsidian';
	import { type PluginSettings } from '../settings';
	import MapViewPlugin from '../main';
	import { verifyOrAddFrontMatterForInline } from '../utils';

	let {
		plugin, app, close, settings, editor, file
	} = $props<{
		plugin: MapViewPlugin;
		app: App;
		close: () => void;
		settings: PluginSettings;
		editor: Editor;
		file: TFile;
	}>();

	let fileInput = $state<HTMLInputElement>();
	let selectedFileName = $state('');
	let templateText = $state(`- [{{name}}](geo:{{coordinates}})`);
	let previewText = $state('');
	let fileContent = $state('');
	type Field = {
		xmlName: string,
		template: string,
		formatter?: (text: string) => string
	};
	const fields: Field[] = [
		{ xmlName: 'name', template: '{{name}}' },
		{ xmlName: 'coordinates', template: '{{coordinates}}', formatter: formatCoordinates },
		{ xmlName: 'address', template: '{{address}}' },
		{ xmlName: 'phoneNumber', template: '{{phoneNumber}}' },
		{ xmlName: 'description', template: '{{description}}' }
	];

	$effect(() => {
		if (selectedFileName && templateText) {
			previewText = kmlImport(fileContent, templateText);
		}
	});

	async function handleFileSelect(event: Event) {
		const target = event.target as HTMLInputElement;
		const files = target.files;
		if (files && files.length > 0) {
			selectedFileName = files[0].name;

			// Read the file content
			const file = files[0];
			try {
				fileContent = await file.text();
				previewText = kmlImport(fileContent, templateText);
			} catch (error) {
				console.error('Error reading file:', error);
				previewText = 'Error reading file';
			}
		}
	}

	function formatCoordinates(coordinates: string) {
		const [longitude, latitude] = coordinates.split(',').map(coord => coord.trim());
		return `${latitude},${longitude}`;
	}

	function kmlImport(content: string, template: string) {
		const parser = new DOMParser();
		const xmlDoc = parser.parseFromString(content, 'application/xml');

		// Extract folder name
		let title = null;
		const folderNameElement = xmlDoc.querySelector('Folder > name');
		if (folderNameElement) {
			title = folderNameElement.textContent;
		}

		// Initialize Markdown output
		let markdownOutput = '';

		// Add folder name as a heading if available
		if (title != null) {
			markdownOutput += `## ${title}\n\n`;
		}
		markdownOutput += `Imported on ${new Date().toISOString().split('T')[0]}\n\n`;

		const placemarks = xmlDoc.querySelectorAll('Placemark');
		for (const placemark of placemarks) {
			const elementToText = (elem: Element) => elem == null ? "" : elem.textContent?.trim() ?? "";

			let formattedText = template;
			for (const field of fields) {
				const value = elementToText(placemark.querySelector(field.xmlName));
				if (value) {
					const formattedValue = field.formatter ? field.formatter(value) : value;
					formattedText = formattedText.replace(field.template, formattedValue);
				}
			}

			markdownOutput += formattedText + '\n';
		}
		return markdownOutput;
	}

	async function importIntoNote() {
		if (previewText) {
			await verifyOrAddFrontMatterForInline(app, editor, file, settings);
			editor.replaceSelection(previewText);
		}
		close();
	}

</script>

<div class="import-dialog">
	<div class="setting-item-container">
		<div class="setting-item-heading">Import Geolocations from File</div>
		<div class="setting-item-description">
			This tool allows batch-importing geolocations from KML files generated by Google Maps.
		</div>

		<div class="setting-item">
			<div class="setting-item-info">
				<div class="setting-item-name">Input file</div>
				<div class="setting-item-description">Select a file to import.</div>
			</div>
			<div class="setting-item-control">
				<input 
					type="file" 
					accept=".kml"
					style="display: none"
					bind:this={fileInput}
					onchange={handleFileSelect}
				/>
				{#if selectedFileName}
					<span class="selected-file">{selectedFileName}</span>
				{/if}
				<button 
					class="mod-cta" 
					onclick={() => fileInput?.click()}
				>
					Select File...
				</button>
			</div>
		</div>
	</div>

	<div class="setting-item template-container">
		<div class="setting-item-info">
			<div class="setting-item-name">Template text to use</div>
			<div class="setting-item-description">
				<p>Available fields:</p>
				<p style="font-family: var(--font-monospace);">
					{fields.map(field => field.template).join(', ')}
				</p>
			</div>
		</div>
		<textarea
			rows="2"
			bind:value={templateText}
		>
		</textarea>
	</div>

	<div class="setting-item preview-container">
		<div class="setting-item-info">
			<div class="setting-item-name">Preview</div>
		</div>
		<textarea
			rows="6"
			readonly
			bind:value={previewText}
		></textarea>
	</div>

	<div class="setting-item">
		<div class="setting-item-control">
			<button class="mod-cta" onclick={importIntoNote} disabled={!previewText}>
				Import into Note
			</button>
			<button class="mod-cta" onclick={close}>
				Cancel
			</button>
		</div>
	</div>


</div>

<style>
	.selected-file {
		margin-left: 10px;
		color: var(--text-muted);
		font-size: 0.9em;
		max-width: 16ch;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
		display: inline-block;
		vertical-align: middle;
	}

	.template-container,
	.preview-container {
		display: block !important;
	}

	.template-container .setting-item-info,
	.preview-container .setting-item-info {
		padding-bottom: var(--size-4-1);
	}

	textarea {
		width: 100%;
		resize: vertical;
		background-color: var(--background-modifier-form-field);
		border: var(--input-border-width) solid var(--background-modifier-border);
		color: var(--text-muted);
		font-family: var(--font-monospace);
		padding: var(--size-4-1);
		border-radius: var(--radius-s);
		min-height: 80px;
	}
</style>

