import * as leaflet from 'leaflet';
import 'leaflet-extra-markers';
import 'leaflet-extra-markers/dist/css/leaflet.extra-markers.min.css';
// Ugly hack for obsidian-leaflet compatability, see https://github.com/esm7/obsidian-map-view/issues/6
// @ts-ignore
let localL = L;
import wildcard from 'wildcard';

import { MarkerIconRule } from 'src/settings';

export function getIconFromRules(
    tags: string[],
    rules: MarkerIconRule[],
    iconCache: IconCache
) {
    // We iterate over the rules and apply them one by one, so later rules override earlier ones
    let result = rules.find((item) => item.ruleName === 'default').iconDetails;
    for (const rule of rules) {
        if (checkTagPatternMatch(rule.ruleName, tags)) {
            result = Object.assign({}, result, rule.iconDetails);
        }
    }
    return getIconFromOptions(result, iconCache);
}

export function getIconFromOptions(
    iconSpec: leaflet.ExtraMarkers.IconOptions,
    iconCache: IconCache
): leaflet.Icon {
    // Ugly hack for obsidian-leaflet compatability, see https://github.com/esm7/obsidian-map-view/issues/6
    // @ts-ignore
    const backupL = L;
    try {
        // @ts-ignore
        L = localL;
        // The behavior of Leaflet Extra Markers is to render Fonr Awesome with Web Fonts & CSS, which has
        // proven too slow for displaying hundreds of markers.
        // This overrides the HTML generated by Extra Market to use the SVG Symbols alternative, which
        // seems much faster.
        // See here for more details: https://fontawesome.com/v5/docs/web/advanced/svg-symbols
        const iconId = iconCache.getIconIdAndCache(iconSpec);
        iconSpec.innerHTML = `<svg class="map-view-icon"><use xlink:href="#${iconId}"></use></svg>`;
        return leaflet.ExtraMarkers.icon(iconSpec);
    } finally {
        // @ts-ignore
        L = backupL;
    }
}

type IconCacheItem = {
    iconSpec: leaflet.ExtraMarkers.IconOptions;
    idInDocument: string;
};

// The "SVG + JS" method to render Font Awesome requires to create IMG elements once, for each
// specific icon we create, and then reference to them where they are used, see here:
// https://fontawesome.com/docs/web/dig-deeper/webfont-vs-svg
// Over here we save a cache of which icon combinations we already created, so we can refer to them
// when an actual icon is needed.
export class IconCache {
    private iconDefinitions: HTMLDivElement = null;
    private iconCache: Map<string, IconCacheItem> = new Map();

    constructor(containerEl: HTMLElement) {
        this.iconDefinitions = containerEl.createDiv('icons');
    }

    getIconIdAndCache(iconSpec: leaflet.ExtraMarkers.IconOptions) {
        const hashFunction = (s: string) =>
            s
                .split('')
                .reduce((a, b) => ((a << 5) - a + b.charCodeAt(0)) | 0, 0);
        let iconSpecWithoutHtml = iconSpec;
        iconSpecWithoutHtml.innerHTML = null;
        const iconHash = hashFunction(
            JSON.stringify(iconSpecWithoutHtml)
        ).toString();
        const cachedIcon = this.iconCache.get(iconHash);
        if (cachedIcon) {
            return cachedIcon.idInDocument;
        } else {
            const newIcon = this.iconDefinitions.createEl('img');
            const idInDocument = `icon-${iconHash}`;
            newIcon.width = 15;
            newIcon.height = 15;
            newIcon.setAttribute('data-fa-symbol', idInDocument);
            newIcon.style.color = iconSpec.iconColor ?? 'white';
            // TODO set attributes
            newIcon.addClasses([iconSpec.prefix, iconSpec.icon]);
            this.iconCache.set(iconHash, { iconSpec, idInDocument });
            return idInDocument;
        }
    }
}

export function checkTagPatternMatch(tagPattern: string, tags: string[]) {
    let match = wildcard(tagPattern, tags);
    return match && match.length > 0;
}
