import * as leaflet from 'leaflet';
import 'leaflet-extra-markers';
import 'leaflet-extra-markers/dist/css/leaflet.extra-markers.min.css';
// Ugly hack for obsidian-leaflet compatability, see https://github.com/esm7/obsidian-map-view/issues/6
// @ts-ignore
let localL = L;
import wildcard from 'wildcard';

import { MarkerIconRule } from 'src/settings';

export function getIconFromRules(
    tags: string[],
    rules: MarkerIconRule[],
    iconCache: IconCache
) {
    // We iterate over the rules and apply them one by one, so later rules override earlier ones
    let shape = null;
    let result = rules.find((item) => item.ruleName === 'default').iconDetails;
    for (const rule of rules) {
        if (checkTagPatternMatch(rule.ruleName, tags)) {
            result = Object.assign({}, result, rule.iconDetails);
            shape = rule.iconDetails.shape;
        }
    }
    return getIconFromOptions(result, iconCache, shape);
}

export function getIconFromOptions(
    iconSpec: leaflet.ExtraMarkers.IconOptions,
    iconCache: IconCache,
    shape: any = null
): leaflet.Icon | leaflet.DivIcon {
    // Ugly hack for obsidian-leaflet compatability, see https://github.com/esm7/obsidian-map-view/issues/6
    // @ts-ignore
    const backupL = L;
    try {
        // If the shape is set to resizable-circle we will draw the circle marker itself. This makes it
        // possible to resize the marker (make it grow or shrink) based on the number of edges (lines)
        // connected to a given node. Otherwise, we let leaflet.ExtraMarkers handle the drawing of marker
        // icons.
        if (shape === 'resizable-circle') {
            return createCircleMarker(iconSpec.markerColor, [
                iconSpec.icon,
                iconSpec.prefix,
            ]);
        } else {
            // @ts-ignore
            L = localL;
            // The behavior of Leaflet Extra Markers is to render Font Awesome with Web Fonts & CSS, which has
            // proven too slow for displaying hundreds of markers.
            // This overrides the HTML generated by Extra Markers to use the SVG Symbols alternative, which
            // seems much faster.
            // See here for more details: https://fontawesome.com/v5/docs/web/advanced/svg-symbols
            const iconId = iconCache.getIconIdAndCache(iconSpec);
            iconSpec.innerHTML = `<svg class="map-view-icon"><use xlink:href="#${iconId}"></use></svg>`;
            return leaflet.ExtraMarkers.icon(iconSpec);
        }
    } finally {
        // @ts-ignore
        L = backupL;
    }
}

export function createCircleMarkerBasedOnDegree(
    color: string = 'red',
    iconClasses: string[] = ['fas', 'fa-person'],
    degree: number = 0,
    degrees: number[] = []
): leaflet.DivIcon {
    let size = 20;
    let anchor = 10;
    let step = degrees.length <= 5 ? 1 : Math.ceil(degrees.length / 5);
    for (let i = step - 1; i < degrees.length; i += step) {
        if (degree <= degrees[i]) {
            // we found the correct bucket/percentile
            break;
        }
        size += 4;
        anchor += 2;
    }
    return createCircleMarker(color, iconClasses, size, anchor);
}

export function createCircleMarker(
    color: string = 'red',
    iconClasses: string[] = ['fas', 'fa-person'],
    iconSize: number = 30,
    iconAnchor: number = 15
): leaflet.DivIcon {
    let circleStyle = `
        background-color: ${color ?? 'red'};
        border: none;
        border-radius: 50%;
        width: ${iconSize}px;
        height: ${iconSize}px;
        display: flex;
        justify-content: center;
        align-items: center;
        color: white;
    `;
    let fontSize = Math.ceil(iconSize * 0.66);
    let circleIcon = leaflet.divIcon({
        className: '', // Disable default Leaflet icon styles
        html: `<div style="${circleStyle}"><i style="font-size: ${fontSize}px;" class="${iconClasses.join(
            ' '
        )}"></i></div>`,
        iconSize: [iconSize, iconSize],
        iconAnchor: [iconAnchor, iconAnchor],
    });
    return circleIcon;
}

type IconCacheItem = {
    iconSpec: leaflet.ExtraMarkers.IconOptions;
    idInDocument: string;
};

// The "SVG + JS" method to render Font Awesome requires to create IMG elements once, for each
// specific icon we create, and then reference to them where they are used, see here:
// https://fontawesome.com/docs/web/dig-deeper/webfont-vs-svg
// Over here we save a cache of which icon combinations we already created, so we can refer to them
// when an actual icon is needed.
export class IconCache {
    private iconDefinitions: HTMLDivElement = null;
    private iconCache: Map<string, IconCacheItem> = new Map();

    constructor(containerEl: HTMLElement) {
        this.iconDefinitions = containerEl.createDiv('icons');
    }

    getIconIdAndCache(iconSpec: leaflet.ExtraMarkers.IconOptions) {
        const hashFunction = (s: string) =>
            s
                .split('')
                .reduce((a, b) => ((a << 5) - a + b.charCodeAt(0)) | 0, 0);
        let iconSpecWithoutHtml = iconSpec;
        iconSpecWithoutHtml.innerHTML = null;
        const iconHash = hashFunction(
            JSON.stringify(iconSpecWithoutHtml)
        ).toString();
        const cachedIcon = this.iconCache.get(iconHash);
        if (cachedIcon) {
            return cachedIcon.idInDocument;
        } else {
            const newIcon = this.iconDefinitions.createEl('img');
            const idInDocument = `icon-${iconHash}`;
            newIcon.width = 15;
            newIcon.height = 15;
            newIcon.setAttribute('data-fa-symbol', idInDocument);
            newIcon.style.color = iconSpec.iconColor ?? 'white';
            // TODO set attributes
            newIcon.addClasses([iconSpec.prefix, iconSpec.icon]);
            this.iconCache.set(iconHash, { iconSpec, idInDocument });
            return idInDocument;
        }
    }
}

export function checkTagPatternMatch(tagPattern: string, tags: string[]) {
    let match = wildcard(tagPattern, tags);
    return match && match.length > 0;
}
